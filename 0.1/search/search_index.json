{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Antelopy","text":"<p>Python serializer for Antelope blockchain transaction data</p>"},{"location":"#overview","title":"Overview","text":"<p>Since Leap 3.1, the <code>abi_json_to_bin</code> endpoint has been deprecated to ensure the integrity of transaction data. Antelopy offers an drop-in serialization option to support Python-based interaction with Antelope blockchains.</p> <p>Antelopy supports the following libraries.</p> Antelope Library Support Status Guide aioeos  Fully integrated Link eospy (archived Jan 2024)  Serialization supported Link pyntelope  To do N/A"},{"location":"api/","title":"Test page","text":""},{"location":"usage/aioeos/","title":"Serialization with aioeos","text":"<p>Antelopy has full integration for the aioeos package. </p>"},{"location":"usage/aioeos/#simple-token-transfer","title":"Simple token transfer","text":"<p>In this example, a simple token transfer is performed. It is assumed that you have used <code>aioeos</code> before, and this guide won't cover the usage of the package.</p>"},{"location":"usage/aioeos/#initialisation","title":"Initialisation","text":"<p>First, import necessary modules, and then initialize the ABI cache, reading the <code>eosio.token</code> account's ABI from chain.</p> <p>Python<pre><code>import asyncio\nfrom decimal import Decimal\nfrom typing import List\n\nfrom aioeos import EosAccount, EosAction, EosJsonRpc, EosTransaction\nfrom antelopy import AbiCache\n\nCHAIN_ENDPOINT = \"https://waxtestnet.greymass.com\"\n\nabi_cache = AbiCache(\n    chain_endpoint=CHAIN_ENDPOINT, \n    chain_package=\"aioeos\", \n)\nabi_cache.read_abi(\"eosio.token\")\n</code></pre> Make sure to include the <code>chain_package</code> parameter when creating the AbiCache.</p>"},{"location":"usage/aioeos/#aioeos-configuration","title":"aioeos configuration","text":"<p>Next is defining an RPC, account, and transfer action to use with <code>aioeos</code>.</p> <p>Danger</p> <p>Don't put your keys in your code. Hardcoding your private key into your code is a huge security risk.</p> <p>For production environments, check out OWASP's cheat sheet on secrets management.</p> <p>For working locally, check out the Secrets Management article from Microsoft's Code With Engineering Playbook for tips on ways to manage secrets for local development. </p> <p>The private key in the example below is one that was randomly generated for these docs, and is not the real key.</p> Python<pre><code>RPC = EosJsonRpc(CHAIN_ENDPOINT)\n\n# Configuring the WAX account that will be used to sign the transaction.\n# DO NOT put your key directly in your code.\nwax_account = EosAccount(\n    name=\"professoroak\",\n    private_key=\"5J2yE5oNnEfAmdBQtzLTo979ptHXXidmQXNvDcAFP9AJVMKnmkb\"\n)\n\n# Making the transfer action\ntransfer_value = Decimal(\"3.14\").quantize(Decimal(\"1.00000000\")) # (1)!\ntransfer_action = EosAction(\n    account=\"eosio.token\",\n    name=\"transfer\",\n    authorization=[wax_account.authorization(\"active\")],\n    data={\n        \"from\": wax_account.name,\n        \"to\": \"officerjenny\",\n        \"quantity\": f\"{transfer_value} WAX\",\n        \"memo\": \"This is an example transfer!\",\n    },\n)\n</code></pre> <ol> <li>I strongly recommend using python's decimal module to handle numbers, especially when calculating values. <code>Decimal.quantize</code> can be used to format the value to the correct precision. e.g. <code>Decimal(\"3.14\").quantize(Decimal(\"1.00000000\"))</code> = <code>Decimal(\"3.14000000\")</code></li> </ol>"},{"location":"usage/aioeos/#pushing-the-transaction","title":"Pushing the transaction","text":"<p>We now need to create an async function to handle signing the transaction and pushing it to the blockchain.</p> Python<pre><code>async def main():\n    block = await RPC.get_head_block()\n    transaction = EosTransaction(\n        ref_block_num=block[\"block_num\"] &amp; 65535,\n        ref_block_prefix=block[\"ref_block_prefix\"],\n        actions=[transfer_action],\n    )\n    chain_response = await abi_cache.async_sign_and_push(\n        RPC, \n        [wax_account], \n        transaction\n    )\n    return chain_response\n</code></pre> <p>The <code>async_sign_and_push</code> function</p> <p>The <code>async_sign_and_push</code> function in line 46 takes the following arguments:  </p> Parameter Description Value in example <code>rpc</code> an <code>EosJsonRpc</code> instance <code>RPC</code> <code>signing_accounts</code> <code>list</code> of <code>EosAccount</code> instances <code>[wax_account]</code> <code>trx</code> an <code>EosTransaction</code> instance <code>transaction</code> <p>The AbiCache knows from the <code>chain_package=\"aioeos\"</code> declaration back in the initialisation step that it will be receiving instances of <code>aioeos</code> classes, and handles the serialization and signing of the transaction accordingly. It then uses the RPC that was passed in the function to push the transaction to the blockchain.</p> <p>Finally, we call the async function. The returned response is a <code>dict</code> containing the JSON response from the endpoint.</p> Python<pre><code>if __name__ == \"__main__\":\n    response_from_blockchain = asyncio.run(main())\n</code></pre>"},{"location":"usage/aioeos/#the-whole-script","title":"The whole script","text":"Python<pre><code>import asyncio\nfrom decimal import Decimal\nfrom typing import List\n\nfrom aioeos import EosAccount, EosAction, EosJsonRpc, EosTransaction\nfrom antelopy import AbiCache\n\nCHAIN_ENDPOINT = \"https://waxtestnet.greymass.com\"\n\nabi_cache = AbiCache(\n    chain_endpoint=CHAIN_ENDPOINT, \n    chain_package=\"aioeos\", \n)\nabi_cache.read_abi(\"eosio.token\")\n\nRPC = EosJsonRpc(CHAIN_ENDPOINT)\n\n# Configuring the WAX account that will be used to sign the transaction.\n# DO NOT put your key directly in your code.\nwax_account = EosAccount(\n    name=\"professoroak\",\n    private_key=\"5J2yE5oNnEfAmdBQtzLTo979ptHXXidmQXNvDcAFP9AJVMKnmkb\"\n)\n\n# Making the transfer action\ntransfer_value = Decimal(\"3.14\").quantize(Decimal(\"1.00000000\")) # (1)!\ntransfer_action = EosAction(\n    account=\"eosio.token\",\n    name=\"transfer\",\n    authorization=[wax_account.authorization(\"active\")],\n    data={\n        \"from\": wax_account.name,\n        \"to\": \"officerjenny\",\n        \"quantity\": f\"{transfer_value} WAX\",\n        \"memo\": \"This is an example transfer!\",\n    },\n)\n\nasync def main():\n    block = await RPC.get_head_block()\n    transaction = EosTransaction(\n        ref_block_num=block[\"block_num\"] &amp; 65535,\n        ref_block_prefix=block[\"ref_block_prefix\"],\n        actions=[transfer_action],\n    )\n    chain_response = await abi_cache.async_sign_and_push(\n        RPC, \n        [wax_account], \n        transaction\n    )\n    return chain_response\n\n if __name__ == \"__main__\":\n    response_from_blockchain = asyncio.run(main())\n</code></pre>"},{"location":"usage/eospy/","title":"Serialization with eospy","text":"<p>Note</p> <p><code>eospy</code> support is currently in development and does not yet have a stable release.</p> <p>Antelopy currently has partial support for the eospy package.</p>"},{"location":"usage/installation/","title":"Installation","text":""},{"location":"usage/installation/#using-pip","title":"Using pip","text":"<p>antelopy can be installed from PyPI.</p> Bash<pre><code>pip install antelopy\n</code></pre>"},{"location":"usage/installation/#using-source","title":"Using source","text":"<p>Releases of antelopy can be found on GitHub.</p>"},{"location":"usage/the_abi_cache/","title":"The ABI Cache","text":"<p>At the core of antelopy is the AbiCache class, which stores ABI files and uses them to serialize transaction data into the format required by Antelope smart contracts.</p>"},{"location":"usage/the_abi_cache/#initialisation","title":"Initialisation","text":"<p>AbiCache instances must be created with the url for a Antelope chain endpoint. In this example, a WAX testnet endpoint is used.</p> Python<pre><code>from antelopy import AbiCache\n\nabi_cache = AbiCache(chain_endpoint=\"https://waxtestnet.greymass.com\")\n</code></pre>"},{"location":"usage/the_abi_cache/#initialisation-for-use-with-another-library","title":"Initialisation for use with another library","text":"<p>Note</p> <p>Full integration is currently only supported with <code>aioeos</code></p> Python<pre><code>from antelopy import AbiCache\n\nabi_cache = AbiCache(\n    chain_endpoint=\"https://waxtestnet.greymass.com\", \n    chain_package=\"aioeos\", \n)\n</code></pre> <p>This lets antelopy know which library you're working with, as each transactions/actions from each library need to be handled differently.</p>"},{"location":"usage/the_abi_cache/#working-with-abis","title":"Working with ABIs","text":""},{"location":"usage/the_abi_cache/#reading-abis-from-the-blockchain","title":"Reading ABIs from the blockchain","text":"<p>The <code>read_abi</code> method of the AbiCache requests a smart contract's ABI from the chain endpoint. This is not asynchronous. The name of the contract account is passed to the function as an argument. Python<pre><code>from antelopy import AbiCache\n\nabi_cache = AbiCache(chain_endpoint=\"https://waxtestnet.greymass.com\")\nabi_cache.read_abi(\"eosio.token\")\n</code></pre> In this example, the <code>eosio.token</code> smart contract is loaded into the cache from the WAX Testnet.</p>"},{"location":"usage/the_abi_cache/#reading-abis-from-the-local-filesystem","title":"Reading ABIs from the local filesystem","text":"<p>ABIs can also be read from a local file using <code>read_abi_from_json</code>. In addition to the name of the contract account, a path to a json-formatted ABI file is passed to the function. Python<pre><code>from antelopy import AbiCache\n\nabi_cache = AbiCache(chain_endpoint=\"https://waxtestnet.greymass.com\")\nabi_cache.read_abi_from_json(\"atomicassets\", \"example_abi_directory/atomicassets.abi\")\n</code></pre></p>"},{"location":"usage/the_abi_cache/#saving-abis-to-the-local-filesystem","title":"Saving ABIs to the local filesystem","text":"<p>For efficiency, you may wish to save commonly used ABIs locally, so that they don't need to be requested from the chain endpoint each time you initialise the AbiCache. The <code>dump_abi</code> method saves an ABI from the cache locally, taking the name of the contract account and a destination path as arguments.</p> Python<pre><code>from antelopy import AbiCache\n\nabi_cache = AbiCache(chain_endpoint=\"https://waxtestnet.greymass.com\")\nabi_cache.read_abi(\"eosio.token\")\n\nabi_cache.dump_abi(\"eosio.token\", \"example_abi_directory/eosio.token.abi\")\n</code></pre> <p>Note</p> <p>Keep in mind that if the smart contract is updated on chain, you'll likely need to re-download the ABI.</p>"}]}