{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"antelopy","text":"<p>Documentation: https://antelopy.stuckatsixpm.com Source Code: https://github.com/stuckatsixpm/antelopy </p> <p>antelopy serializes transaction data for Antelope blockchains, integrating with existing Python packages for ease of use.</p> <p>In the Antelope's Leap 3.1 release,, the <code>abi_json_to_bin</code> endpoint was deprecated to ensure the integrity of transaction data. However, available options for interacting with Antelope chains with Python all rely on this endpoint for the serialization step. antelopy is designed to handle this process in a non-intrusive way, minimizing changes users of aioeos and eospy need to make.</p> <p>Usage Guide</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Serialize transaction data in preparation for transaction  </li> <li>Read ABIs from the blockchain or file, with the option to save for reuse  </li> <li>Integration wrappers around aioeos and eospy </li> </ul> <p>antelopy supports the following libraries.</p> Antelope Library Support Status Guide Repository aioeos  Fully integrated Link Link eospy  Fully integrated<sup>1</sup> Link Link pyntelope  Waiting for update N/A Link"},{"location":"#sponsors","title":"Sponsors","text":"<ol> <li> <p>eospy's GitHub repository was archived Jan 2024\u00a0\u21a9</p> </li> </ol>"},{"location":"api/","title":"API Reference","text":"<p>This section of the docs is currently being written. </p> <p>In the meantime, have a look at the usage guides for examples of how to use antelopy</p> <p>Stay tuned for updates!</p>"},{"location":"usage/","title":"Learn to use antelopy","text":"<p>This section covers the basic usage of antelopy, with annotated code examples.</p>"},{"location":"usage/#getting-started-with-antelopy","title":"Getting started with antelopy","text":"<ul> <li>Installation</li> <li>The ABI Cache</li> </ul>"},{"location":"usage/#serializing-transactions","title":"Serializing transactions","text":"<ul> <li>Working with aioeos</li> <li>Working with eospy</li> </ul>"},{"location":"usage/aioeos/","title":"Serialization with aioeos","text":"<p>antelopy has full integration for the aioeos package. </p>"},{"location":"usage/aioeos/#simple-token-transfer","title":"Simple token transfer","text":"<p>In this example, a simple token transfer is performed. It is assumed that you have used aioeos before, and this guide won't cover the usage of the package.</p>"},{"location":"usage/aioeos/#initialisation","title":"Initialisation","text":"<p>First, import necessary modules, and then initialize the ABI cache, reading the <code>eosio.token</code> account's ABI from chain.</p> <p>Python<pre><code>import asyncio\nfrom decimal import Decimal\n\nfrom aioeos import EosAccount, EosAction, EosJsonRpc, EosTransaction\n\nfrom antelopy import AbiCache\n\nCHAIN_ENDPOINT = \"https://waxtestnet.greymass.com\"\n\nabi_cache = AbiCache(\n    chain_endpoint=CHAIN_ENDPOINT,\n    chain_package=\"aioeos\",\n)\nabi_cache.read_abi(\"eosio.token\")\n</code></pre> Make sure to include the <code>chain_package</code> parameter when creating the AbiCache.</p>"},{"location":"usage/aioeos/#aioeos-configuration","title":"aioeos configuration","text":"<p>Next is defining an RPC and account to use with aioeos.</p> <p>Danger</p> <p>Don't put your keys in your code. Hardcoding your private key into your code is a huge security risk.</p> <p>For production environments, check out OWASP's cheat sheet on secrets management.</p> <p>For working locally, check out the Secrets Management article from Microsoft's Code With Engineering Playbook for tips on ways to manage secrets for local development. </p> <p>The private key in the example below is one that was randomly generated for these docs, and is not the real key.</p> Python<pre><code>RPC = EosJsonRpc(CHAIN_ENDPOINT)\n\n# DO NOT put your key directly in your code.\nwax_account = EosAccount(\n    name=\"professoroak\",\n    private_key=\"5J2yE5oNnEfAmdBQtzLTo979ptHXXidmQXNvDcAFP9AJVMKnmkb\",\n)\n</code></pre>"},{"location":"usage/aioeos/#creating-the-transaction","title":"Creating the transaction","text":"<p>First, the transfer action and an <code>aioeos.EosTransaction</code> are created, and then the AbiCache's <code>async_sign_and_push</code> function is used to serialize the transaction, sign it, and asynchronously send it to the chain endpoint.</p> Python<pre><code>async def transfer_token():\n    transfer_value = Decimal(\"3.14\").quantize(Decimal(\"1.00000000\")) # (1)!\n    transfer_action = EosAction(\n        account=\"eosio.token\",\n        name=\"transfer\",\n        authorization=[wax_account.authorization(\"active\")],\n        data={\n            \"from\": wax_account.name,\n            \"to\": \"officerjenny\",\n            \"quantity\": f\"{transfer_value} WAX\",\n            \"memo\": \"This is an example transfer!\",\n        },\n    )\n\n    block = await RPC.get_head_block()\n    transaction = EosTransaction(\n        ref_block_num=block[\"block_num\"] &amp; 65535,\n        ref_block_prefix=block[\"ref_block_prefix\"],\n        actions=[transfer_action],\n    )\n    chain_response = await abi_cache.async_sign_and_push(\n        RPC, [wax_account], transaction\n    )\n    return chain_response\n</code></pre> <ol> <li>I strongly recommend using python's decimal module to handle numbers, especially when calculating values. <code>Decimal.quantize</code> can be used to format the value to the correct precision. e.g. <code>Decimal(\"3.14\").quantize(Decimal(\"1.00000000\"))</code> = <code>Decimal(\"3.14000000\")</code></li> </ol> <p>The <code>async_sign_and_push</code> function</p> <p>The <code>async_sign_and_push</code> function in line 45 takes the following arguments:  </p> Parameter Description Value in example <code>rpc</code> an <code>EosJsonRpc</code> instance <code>RPC</code> <code>signing_accounts</code> <code>list</code> of <code>EosAccount</code> instances <code>[wax_account]</code> <code>trx</code> an <code>EosTransaction</code> instance <code>transaction</code> <p>The AbiCache knows from the <code>chain_package=\"aioeos\"</code> declaration back in the initialisation step that it will be receiving instances of aioeos classes, and handles the serialization and signing of the transaction accordingly. It then uses the RPC that was passed in the function to push the transaction to the blockchain.</p> <p>Finally, we call the async function. The returned response is a <code>dict</code> containing the JSON response from the endpoint.</p> Python<pre><code>if __name__ == \"__main__\":\n    response_from_blockchain = asyncio.run(transfer_token())\n</code></pre>"},{"location":"usage/aioeos/#the-whole-script","title":"The whole script","text":"Python<pre><code>import asyncio\nfrom decimal import Decimal\n\nfrom aioeos import EosAccount, EosAction, EosJsonRpc, EosTransaction\n\nfrom antelopy import AbiCache\n\nCHAIN_ENDPOINT = \"https://waxtestnet.greymass.com\"\n\nabi_cache = AbiCache(\n    chain_endpoint=CHAIN_ENDPOINT,\n    chain_package=\"aioeos\",\n)\nabi_cache.read_abi(\"eosio.token\")\n\nRPC = EosJsonRpc(CHAIN_ENDPOINT)\n\n# DO NOT put your key directly in your code.\nwax_account = EosAccount(\n    name=\"professoroak\",\n    private_key=\"5J2yE5oNnEfAmdBQtzLTo979ptHXXidmQXNvDcAFP9AJVMKnmkb\",\n)\n\n\nasync def transfer_token():\n    transfer_value = Decimal(\"3.14\").quantize(Decimal(\"1.00000000\"))\n    transfer_action = EosAction(\n        account=\"eosio.token\",\n        name=\"transfer\",\n        authorization=[wax_account.authorization(\"active\")],\n        data={\n            \"from\": wax_account.name,\n            \"to\": \"officerjenny\",\n            \"quantity\": f\"{transfer_value} WAX\",\n            \"memo\": \"This is an example transfer!\",\n        },\n    )\n\n    block = await RPC.get_head_block()\n    transaction = EosTransaction(\n        ref_block_num=block[\"block_num\"] &amp; 65535,\n        ref_block_prefix=block[\"ref_block_prefix\"],\n        actions=[transfer_action],\n    )\n    chain_response = await abi_cache.async_sign_and_push(\n        RPC, [wax_account], transaction\n    )\n    return chain_response\n\n\nif __name__ == \"__main__\":\n    response_from_blockchain = asyncio.run(transfer_token())\n</code></pre>"},{"location":"usage/eospy/","title":"Serialization with eospy","text":"<p>Antelopy has full integration for the eospy package.</p> <p>Warning</p> <p>eospy was archived in January 2024. While antelopy currently supports eospy, the package itself is unlikely to receive updates in future from the developers.</p> <p>Note</p> <p>When installing eospy, remember that the package is <code>libeospy</code> on PyPI.</p>"},{"location":"usage/eospy/#simple-token-transfer","title":"Simple token transfer","text":"<p>In this example, a simple token transfer is performed. It is assumed that you have used eospy before, and this guide won't cover the usage of the package.</p>"},{"location":"usage/eospy/#initialisation","title":"Initialisation","text":"<p>First, import necessary modules, and then initialize the ABI cache, reading the <code>eosio.token</code> account's ABI from chain.</p> <p>Python<pre><code>from decimal import Decimal\n\nimport eospy.cleos\nimport eospy.keys\n\nfrom antelopy import AbiCache\n\nCHAIN_ENDPOINT = \"https://waxtestnet.greymass.com\"\n\nabi_cache = AbiCache(\n    chain_endpoint=CHAIN_ENDPOINT,\n    chain_package=\"eospy\",\n)\nabi_cache.read_abi(\"eosio.token\")\n</code></pre> Make sure to include the <code>chain_package</code> parameter when creating the AbiCache.</p>"},{"location":"usage/eospy/#eospy-configuration","title":"eospy configuration","text":"<p>Next is defining an RPC and account to use with eospy.</p> <p>Danger</p> <p>Don't put your keys in your code. Hardcoding your private key into your code is a huge security risk.</p> <p>For production environments, check out OWASP's cheat sheet on secrets management.</p> <p>For working locally, check out the Secrets Management article from Microsoft's Code With Engineering Playbook for tips on ways to manage secrets for local development. </p> <p>The private key in the example below is one that was randomly generated for these docs, and is not the real key.</p> Python<pre><code>RPC = eospy.cleos.Cleos(url=CHAIN_ENDPOINT)\n\n# DO NOT put your key directly in your code.\nwax_account = eospy.keys.EOSKey(\"5J2yE5oNnEfAmdBQtzLTo979ptHXXidmQXNvDcAFP9AJVMKnmkb\")\n</code></pre>"},{"location":"usage/eospy/#creating-the-transaction","title":"Creating the transaction","text":"<p>First, the transfer action and an transaction <code>dict</code> are created, and then the AbiCache's <code>sign_and_push</code> function is used to serialize the transaction, sign it, and send it to the chain endpoint.</p> Python<pre><code>def transfer_token():\n    transfer_value = Decimal(\"3.14\").quantize(Decimal(\"1.00000000\"))  # (1)!\n    transfer_action_data = {\n        \"from\": \"professoroak\",\n        \"to\": \"officerjenny\",\n        \"quantity\": f\"{transfer_value} WAX\",\n        \"memo\": \"This is an example transfer!\",\n    }\n    transfer_action = {\n        \"account\": \"eosio.token\",\n        \"name\": \"transfer\",\n        \"authorization\": [\n            {\n                \"actor\": \"professoroak\",\n                \"permission\": \"active\",\n            }\n        ],\n        \"data\": transfer_action_data,\n    }\n\n    transaction = {\"actions\": [transfer_action]}\n    chain_response = abi_cache.sign_and_push(RPC, [wax_account], transaction)\n    return chain_response\n</code></pre> <ol> <li>I strongly recommend using python's decimal module to handle numbers, especially when calculating values. <code>Decimal.quantize</code> can be used to format the value to the correct precision. e.g. <code>Decimal(\"3.14\").quantize(Decimal(\"1.00000000\"))</code> = <code>Decimal(\"3.14000000\")</code></li> </ol> <p>The <code>sign_and_push</code> function</p> <p>The <code>sign_and_push</code> function in line 43 takes the following arguments:  </p> Parameter Description Value in example <code>rpc</code> an <code>eospy.cleos.Cleos</code> instance <code>RPC</code> <code>signing_accounts</code> <code>list</code> of <code>eospy.keys.Keys</code> instances <code>[wax_account]</code> <code>trx</code> a <code>dict</code> containing the transaction <code>transaction</code> <p>The AbiCache knows from the <code>chain_package=\"eospy\"</code> declaration back in the initialisation step that it will be receiving instances of eospy classes, and handles the serialization and signing of the transaction accordingly. It then uses the RPC that was passed in the function to push the transaction to the blockchain.</p> <p>Finally, we call the function. The returned response is a <code>dict</code> containing the JSON response from the endpoint.</p> Python<pre><code>if __name__ == \"__main__\":\n    response_from_blockchain = transfer_token()\n</code></pre>"},{"location":"usage/eospy/#the-whole-script","title":"The whole script","text":"Python<pre><code>from decimal import Decimal\n\nimport eospy.cleos\nimport eospy.keys\n\nfrom antelopy import AbiCache\n\nCHAIN_ENDPOINT = \"https://waxtestnet.greymass.com\"\n\nabi_cache = AbiCache(\n    chain_endpoint=CHAIN_ENDPOINT,\n    chain_package=\"eospy\",\n)\nabi_cache.read_abi(\"eosio.token\")\n\nRPC = eospy.cleos.Cleos(url=CHAIN_ENDPOINT)\n\n# DO NOT put your key directly in your code.\nwax_account = eospy.keys.EOSKey(\"5J2yE5oNnEfAmdBQtzLTo979ptHXXidmQXNvDcAFP9AJVMKnmkb\")\n\n\ndef transfer_token():\n    transfer_value = Decimal(\"3.14\").quantize(Decimal(\"1.00000000\"))\n    transfer_action_data = {\n        \"from\": \"professoroak\",\n        \"to\": \"officerjenny\",\n        \"quantity\": f\"{transfer_value} WAX\",\n        \"memo\": \"This is an example transfer!\",\n    }\n    transfer_action = {\n        \"account\": \"eosio.token\",\n        \"name\": \"transfer\",\n        \"authorization\": [\n            {\n                \"actor\": \"professoroak\",\n                \"permission\": \"active\",\n            }\n        ],\n        \"data\": transfer_action_data,\n    }\n\n    transaction = {\"actions\": [transfer_action]}\n    chain_response = abi_cache.sign_and_push(RPC, [wax_account], transaction)\n    return chain_response\n\n\nif __name__ == \"__main__\":\n    response_from_blockchain = transfer_token()\n</code></pre>"},{"location":"usage/installation/","title":"Installation","text":"<p>antelopy is compatible with Python 3.8 onwards.</p>"},{"location":"usage/installation/#using-pip","title":"Using pip","text":"<p>antelopy can be installed from PyPI.</p> Bash<pre><code>pip install antelopy\n</code></pre>"},{"location":"usage/installation/#using-source","title":"Using source","text":"<p>Releases of antelopy can be found on GitHub.</p>"},{"location":"usage/the_abi_cache/","title":"The ABI Cache","text":"<p>At the core of antelopy is the AbiCache class, which stores ABI files and uses them to serialize transaction data into the format required by Antelope smart contracts.</p>"},{"location":"usage/the_abi_cache/#initialisation","title":"Initialisation","text":"<p>AbiCache instances must be created with the url for a Antelope chain endpoint. In this example, a WAX testnet endpoint is used.</p> Python<pre><code>from antelopy import AbiCache\n\nabi_cache = AbiCache(chain_endpoint=\"https://waxtestnet.greymass.com\")\n</code></pre>"},{"location":"usage/the_abi_cache/#initialisation-for-use-with-another-library","title":"Initialisation for use with another library","text":"<p>Note</p> <p>Full integration is currently only supported with aioeos</p> Python<pre><code>from antelopy import AbiCache\n\nabi_cache = AbiCache(\n    chain_endpoint=\"https://waxtestnet.greymass.com\", \n    chain_package=\"aioeos\", \n)\n</code></pre> <p>This lets antelopy know which library you're working with, as each transactions/actions from each library need to be handled differently.</p>"},{"location":"usage/the_abi_cache/#working-with-abis","title":"Working with ABIs","text":"<p>This section contains examples of how to load ABIs into the AbiCache. It also covers how to write ABIs to the local filesystem for later use, and access the <code>Abi</code> objects within the code.</p>"},{"location":"usage/the_abi_cache/#reading-abis-from-the-blockchain","title":"Reading ABIs from the blockchain","text":"<p>The <code>read_abi</code> method of the AbiCache requests a smart contract's ABI from the chain endpoint. This is not asynchronous. The name of the contract account is passed to the function as an argument. Python<pre><code>from antelopy import AbiCache\n\nabi_cache = AbiCache(chain_endpoint=\"https://waxtestnet.greymass.com\")\nabi_cache.read_abi(\"eosio.token\")\n</code></pre> In this example, the <code>eosio.token</code> smart contract is loaded into the cache from the WAX Testnet.</p>"},{"location":"usage/the_abi_cache/#reading-abis-from-the-local-filesystem","title":"Reading ABIs from the local filesystem","text":"<p>ABIs can also be read from a local file using <code>read_abi_from_json</code>. In addition to the name of the contract account, a path to a json-formatted ABI file is passed to the function. Python<pre><code>from antelopy import AbiCache\n\nabi_cache = AbiCache(chain_endpoint=\"https://waxtestnet.greymass.com\")\nabi_cache.read_abi_from_json(\"atomicassets\", \"example_abi_directory/atomicassets.abi\")\n</code></pre></p>"},{"location":"usage/the_abi_cache/#accessing-abis-within-the-abicache","title":"Accessing ABIs within the AbiCache","text":"<p>antelopy takes care of using ABIs to serialize transaction data, however if you wish to access the ABI instance stored within the cache directly, you can use the <code>get_cached_abi</code> method. This returns an <code>Abi</code> type (documentation for antelopy's internal types will be added in a future docs update).</p> Python<pre><code>from antelopy import AbiCache\n\nabi_cache = AbiCache(chain_endpoint=\"https://waxtestnet.greymass.com\")\nabi_cache.read_abi(\"atomicassets\")\natomicassets_abi = abi_cache.get_cached_abi(\"atomicassets\")\n</code></pre>"},{"location":"usage/the_abi_cache/#saving-abis-to-the-local-filesystem","title":"Saving ABIs to the local filesystem","text":"<p>For efficiency, you may wish to save commonly used ABIs locally, so that they don't need to be requested from the chain endpoint each time you initialise the AbiCache. The <code>dump_abi</code> method saves an ABI from the cache locally, taking the name of the contract account and a destination path as arguments.</p> Python<pre><code>from antelopy import AbiCache\n\nabi_cache = AbiCache(chain_endpoint=\"https://waxtestnet.greymass.com\")\nabi_cache.read_abi(\"eosio.token\")\n\nabi_cache.dump_abi(\"eosio.token\", \"example_abi_directory/eosio.token.abi\")\n</code></pre> <p>Note</p> <p>Keep in mind that if the smart contract is updated on chain, you'll likely need to re-download the ABI.</p>"},{"location":"usage/the_abi_cache/#getting-a-json-str-of-an-abi","title":"Getting a JSON `str`` of an ABI","text":"<p>If you want to get a string dump of an ABI, you can use the </p> Python<pre><code>from antelopy import AbiCache\n\nabi_cache = AbiCache(chain_endpoint=\"https://waxtestnet.greymass.com\")\nabi_cache.read_abi(\"eosio.token\")\n\nabi_cache.dump_abi_as_json(\"eosio.token\")\n</code></pre> <p>Note</p> <p>Keep in mind that if the smart contract is updated on chain, you'll likely need to re-download the ABI.</p>"}]}